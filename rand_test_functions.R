# define recursive function to find all ancestral nodes, and get their
# childern
find_clades <- function(ns, x, elist, nl, tre, out = vector()) {
  # stop condition
  if (sum(elist[, 1] %in% ns) == 0) {
    return(out)
  }
  # main function
  ind <- min(which(elist[, 1] %in% ns))
  sub.node <- elist[ind, 1]
  desc <- getDescendants(tre, sub.node)
  out <- c(out, sub.node, desc)
  # recursion
  ns <- ns[!(ns %in% out)]
  out <- find_clades(ns, x, elist, nl, tre, out)
}

include_parents <- function(nodes, elist, anc, out = nodes) {
  # stop condition
  idx <- which(elist[, 2] %in% nodes)
  if (length(nodes) == 0 | length(idx) == 0) {
    return(out)
  }
  pn <- elist[min(idx), 1]
  out <- union(pn, out)
  torem <- getDescendants(tre, elist[min(idx), 2])
  nodes <- nodes[!nodes %in% c(elist[min(idx), 2], torem)]
  # recursion
  out <- include_parents(nodes, elist, anc, out)
}

make.cost.mat <- function(s, del.bias = 0, expo = F) {
  out <- matrix(0, ncol = max(s) * 2, nrow = max(s) * 2)
  if (expo) {
    x <- 2^(0:ncol(out))
    for (i in 1:(nrow(out) - 1)) {
      out[i, (i + 1):ncol(out)] <- x[1:(ncol(out) - i)]
      out[(i + 1):ncol(out), i] <- x[1:(ncol(out) - i)]
    }
    out[upper.tri(out)] <- out[upper.tri(out)] * del.bias
  } else {
    out[upper.tri(out)] <- del.bias
    out[lower.tri(out)] <- 1
  }
  out
}

sampleFunc <- function(change.mat, rs, n, nchange) {
  require(dqrng)
  if (is.logical(rs)) rs <- which(rs)
  change.mat <- change.mat[, colSums(change.mat[rs, ] != 0) > nchange]
  dqset.seed(1)
  cv <- dqsample.int(ncol(change.mat), length(rs) * n, replace = T)
  rv <- rep(rs, n)
  rnd <- change.mat[cbind(rv, cv)]
  rnd <- matrix(rnd, nrow = length(rs), byrow = T)
  rnd <- rnd[, colSums(rnd != 0) > nchange]
}

extract_cluster_membership <- function(sorted_tsv,prots)
{
  strng <- sprintf("fastEx %s %s | cut -f 2",sorted_tsv,"%s")
  stepsize <- 1000
  if(length(prots) > stepsize)
  {
    out <- list()
    s <- 1
    flg <- T
    while(flg)
    {
      cat(sprintf("%s\n",s))
      e <- s + stepsize - 1
      if(e > length(prots))
      {
        e <- length(prots)
        flg <- F
      }
      ps <- paste(prots[s:e],collapse=" ")   
      cmd <- sprintf(strng,ps)
      out[[as.character(s)]] <- unique(system(cmd,intern=T))
      s <- e + 1
    }
    out <- unique(unlist(out))
  } else
  {
    ps <- paste(prots,collapse=" ")
    cmd <- sprintf(strng,ps)
    out <- unique(system(cmd,intern=T))
  }
  return(out)
}

dbcan_chi <- function(path,gnms)
{
  require(data.table)
  hmm <- fread(path)
  hmm$gnm <- gsub("_\\d+$","",hmm$V1)
  cnt <- hmm[,length(unique(V1)),by=gnm]
  out <- list()
  out$hmm <- hmm
  out$cnt <- rep(0,length(gnms))
  names(out$cnt) <- gnms
  idx <- cnt$gnm %in% gnms
  out$cnt[cnt$gnm[idx]] <- cnt$V1[idx]
  return(out)
}

anc_recon <- function(chi,tre,anc.mode)
{
  cat(sprintf("\t*** anc.mode = %s ***\n", anc.mode))
  cat("\t*** Reconstructing chitinase ancestral states ***\n")
  if (anc.mode == "ML") 
  {
    require(Rphylopars, quietly = T)
    anc.chit <- anc.recon(chi,tre)
    anc.chit <- round(anc.chit)
    anc.chit <- as.vector(anc.chit)
    anc.chit <- c(chi, anc.chit)
    names(anc.chit) <- c(tre$tip.label,(Ntip(tre)+1):length(anc.chit))
  } else if (anc.mode == "MP") 
  {
    require(castor, quietly = T)
    s <- chi[tre$tip.label]
    ms <- min(s)
    s <- s + 1 - ms
    cost.mat <- make.cost.mat(s, 2, T)
    anc.tmp <- asr_max_parsimony(tre, s,
      transition_costs = cost.mat,
      edge_exponent = 0, Nstates = max(s) * 2
    )
    anc.tmp <- max.col(anc.tmp$ancestral_likelihoods) - 1 + ms
    names(anc.tmp) <- (Ntip(tre) + 1):(Ntip(tre) + Nnode(tre))
    anc.chit <- c(s - 1 + ms, anc.tmp)
    rm(s, ms, anc.tmp)
  } else if (anc.mode == "MK")
  {
    require("castor")
    x <- chi
    ms <- min(x)
    x <- x + 1 - ms
    t.mat <- matrix(0,ncol=max(x),nrow=max(x))
    t.mat[row(t.mat)==(col(t.mat)+1)] <- 2
    t.mat[row(t.mat)==(col(t.mat)-1)] <- 1
    diag(t.mat) <- -rowSums(t.mat)
    anc.tmp <- asr_mk_model(tre, x, transition_matrix=t.mat, check_input=F)
    lhr <- rowSums(anc.tmp$ancestral_likelihoods[,-1,drop=F]) / 
      anc.tmp$ancestral_likelihoods[,1]
    anc.tmp <- max.col(anc.tmp$ancestral_likelihoods) - 1 + ms
    anc.tmp[lhr<2] <- min(anc.tmp) 
    anc.chit <- c(chi,anc.tmp)
    names(anc.chit) <- c(tre$tip.label,(Ntip(tre)+1):length(anc.chit))
  }
  return(anc.chit)
}

combine_rand <- function(rdata_dir,out_path)
{
  require(Matrix)
  # combine all files
  files <- dir(rdata_dir, "rand_.+.RData")
  pr <- vector()
  corrs <- vector()
  for (file in files) {
    load(sprintf("%s/%s", rdata_dir, file))
    cat(sprintf( "\t%s,%s,%s\n", file, length(pvs.randomization), length(pcors)))
    tokeep <- !is.na(pvs.randomization)
    pr <- c(pr, pvs.randomization[tokeep])
    corrs <- c(corrs, pcors[tokeep])
  }
  pr.adj <- p.adjust(pr, "fdr")
  save(list = c("pr", "pr.adj", "corrs"), file = out_path)
  out <- list(pr,pr.adj,corrs)
  return(out)
}

get_sig_genes <- function(rand_path,hmm_path,anc_path,out_path,
                          p_thresh,corr_thresh)
{
  require(Matrix)
  require(data.table)
  # make sure there is no "/" at the end of path
  rand_path <- gsub("/$", "", rand_path)
  # load relevant file
  f <- rand_path
  tot_chi <- list()
  pr.adj_l <- list()
  corrs_l <- list()
  load(f)
  # filter NAs
  pr.adj <- pr.adj[!is.na(pr.adj)]
  pr.adj_l[[f]] <- pr.adj 
  corrs <- corrs[!is.na(corrs)]
  corrs_l[[f]] <- corrs
  # get significantly correlated genes that have a positive correlation
  tot_chi[[f]] <- intersect(names(pr.adj)[pr.adj < p_thresh], 
                            names(corrs)[corrs > corr_thresh])
  tot_chi <- unique(unlist(tot_chi))
  names(corrs_l) <- names(pr.adj_l) <- NULL
  pr.adj <- unlist(pr.adj_l)
  corrs <- unlist(corrs_l)
  # read chitinase hmm output
  hmm <- fread(hmm_path)
  torem <- sort(unique(hmm$V1))
  sorted_tsv_path <- "~/nfs2/ncbiGenomes/output/linclust/0.5/0.5_sorted.tsv"
  torem <- extract_cluster_membership(sorted_tsv_path,torem)
  # remove chitinases from tot_chi
  tot_chi <- tot_chi[!(tot_chi %in% torem)]
  # filter diffs for pairwise calculation
  load(anc_path)
  gensize <- rowSums(anc)
  gensize <- gensize[tre$edge[,2]]-gensize[tre$edge[,1]]
  tot_chi <- tot_chi[tot_chi %in% colnames(change.mat)]
  cat(sprintf("%s genes\n",length(tot_chi)))
  idx <- colnames(change.mat) %in% tot_chi
  diffs <- change.mat[, idx]
  diffs <- cbind(diffs,gensize)
  # save
  save(list = c("diffs","gensize"), file = out_path)
  out <- list(diffs,gensize)
  return(out)
}

cos_sim <- function(x,y,gensize,penalty)
{
  if(penalty!=0)
  {
    # add penalty to entries where y changes but x does not
    x <- penalty_func(x,y,penalty)
    y <- penalty_func(y,x,penalty)
    # compute normal cosine similarity
    
  }
  # compute partial cosine similarity
  o1 <- cos_sim_internal(x,y)
  return(o1)
  #xr <- gs_residuals(x,gensize)
  #yr <- gs_residuals(y,gensize)
  #o2 <- cos_sim_internal(xr,yr)
  #return(o2)
  #out <- cbind(t(o1),t(o2))
  #out <- as.matrix(out)
  #colnames(out) <- c("regular","partial")
  #return(out)
}

cos_sim_internal <- function(x,y)
{
  dp <- x %*% y
  nx <- as.vector(sqrt(crossprod(x)))
  if(is.null(dim(y))) 
  {
    ny <- sqrt(crossprod(y))
  } else
  {
    ny <- apply(y,2,function(y) sqrt(crossprod(y)))
  }
  cs <- dp/(nx*ny)
  return(cs) 
}

gs_residuals <- function(x,gensize)
{
  l <- lm(as.matrix(x) ~ gensize)
  return(l$residuals)
}

penalty_func <- function(x,y,penalty)
{
  i1 <- x==0 & y>0
  i2 <- x==0 & y<0
  if(any(i1)) x[i1] <- x[i1]-penalty
  if(any(i2)) x[i2] <- x[i2]+penalty
  return(x)
}

loop_f <- function(ind,penalty,gainloss=F)
{
  # initialize values
  pcors <- pvs.randomization <- 0
  # work
  i <- indx[ind]
  message(sprintf("%s \\ %s", i, ncol(anc)))
  ns <- which(anc[1:nl, i] != 0)
  tips <- rownames(anc)[ns]
  ca <- getMRCA(tre,tips)
  stree <- get_subtree_at_node(tre,ca-Ntip(tre))
  # calculate changes in relevant part of tree
  idx <- stree$new2old_edge
  focal <- change.mat[idx, colnames(anc)[i]]
  if (sum(colSums(change.mat[idx, ] != 0) > minchange) > min_gens) {
    cperm2 <- sampleFunc(change.mat, idx, 2e4, minchange)
  }   
  chit <- anc.chit[tre$edge[,2]] - anc.chit[tre$edge[,1]]
  if(gainloss)
  { 
    chit_s <- gain_loss_changemat(1,as.matrix(anc.chit,ncol=1),tre)
    chit_sm <- sparseMatrix(i=chit_s[,1],j=chit_s[,2],x=chit_s[,3],dims=c(length(chit),1))
    chit <- as.vector(chit_sm)
  }
  chit <- chit[idx]
  
  gensize <- gs[tre$edge[idx, 2]] - gs[tre$edge[idx, 1]]
  if (sum(chit != 0) <= minchange | !exists("cperm2")) {
    message(sprintf("%s \\ %s (not enough chit changes)", i, ncol(anc)))
    pcors <- NA
    pvs.randomization <- NA
  } else {
    if(penalty==0)
    {
      t1 <- lm(chit ~ gensize)$residuals
      t2 <- lm(focal ~ gensize)$residuals
      tmp <- as.vector(cos_sim(t2,t1,gensize,0))
      cperm2 <- lm(cperm2 ~ gensize)$residuals
      rnd <- as.vector(cos_sim(t1,cperm2,gensize,0))
    } else
    {
      tmp <- cos_sim(focal,chit,gensize,penalty) 
      rnd <- apply(cperm2,2,cos_sim,y=chit,gensize=gensize,penalty=penalty)
    }
    pvs.randomization <- sum(rnd>tmp)/length(rnd)
    pcors <- cos_sim(focal,chit,gensize,penalty) 
  }
  out <- list(pcors,pvs.randomization)
  return(out)
}

gain_loss_changemat <- function(ind,anc,tre)
{
  x <- anc[,ind]
  i1 <- tre$edge[,1]  
  i2 <- tre$edge[,2]
  out <- matrix(nrow=0,ncol=3)
  gained <- which(x[i2]>0 & x[i1]==0)
  if (length(gained)>0 ) out <- rbind(out,cbind(gained,ind,1))
  lost <- which(x[i2]==0 & x[i1]>0)
  if (length(lost)>0 ) out <- rbind(out,cbind(lost,ind,-1))
  rownames(out) <- NULL
  colnames(out) <- c("i","j","x")
  return(out)
}
