rand_test <- function(i, j, gs, anc, change.mat, tre, anc.type = "ML") {
  require(Matrix)
  require(phytools)
  require(corpcor)
  require(dqrng)
  require(pcorC)
  

  inds_fun <- function(x,y,cperm2) {
    pcor.shrink(cbind(cperm2[,x[1]],cperm2[,x[2]],y),verbose=F)[2]
  }

  # define recursive function to find all ancestral nodes, and get their
  # childern
  find_clades <- function(ns, x, elist, nl, tre, out = vector()) {
    # stop condition
    if (sum(elist[, 1] %in% ns) == 0) {
      return(out)
    }

    # main function
    ind <- min(which(elist[, 1] %in% ns))
    sub.node <- elist[ind, 1]
    desc <- getDescendants(tre, sub.node)
    out <- c(out, sub.node, desc)

    # recursion
    ns <- ns[!(ns %in% out)]
    out <- find_clades(ns, x, elist, nl, tre, out)
  }

  include_parents <- function(nodes, elist, anc, out = nodes) {

    # stop condition
    idx <- which(elist[, 2] %in% nodes)
    if (length(nodes) == 0 | length(idx) == 0) {
      return(out)
    }

    pn <- elist[min(idx), 1]
    out <- union(pn, out)
    torem <- getDescendants(tre, elist[min(idx), 2])
    nodes <- nodes[!nodes %in% c(elist[min(idx), 2], torem)]

    # recursion
    out <- include_parents(nodes, elist, anc, out)
  }

  sampleFunc <- function(change.mat, rs, n, nchange) {
    if (is.logical(rs)) rs <- which(rs)
    change.mat <- change.mat[, colSums(change.mat[rs, ] != 0) > nchange]
    colvector <- dqsample.int(ncol(change.mat), length(rs) * n, replace = T)
    rowvector <- rep(rs, n)
    rnd <- change.mat[cbind(rowvector, colvector)]
    rnd <- Matrix(rnd, nrow = length(rs), byrow = T, sparse=T)
    rnd <- rnd[, colSums(rnd != 0) > nchange]
  }

  # reorder edge list in reverse postorder,
  # so that nodes near the root come first
  elist <- reorder(tre, "postorder")$edge
  elist <- elist[nrow(elist):1, ]
  nl <- length(tre$tip.label)

  # for each gene, get relevant nodes, compute p-value distributions for both row
  # and column permutations
  ns <- which(anc[, i] != 0 | anc[, j] != 0)
  nodes <- union(ns, find_clades(ns, anc[, i], elist, nl, tre))
  nodes2 <- include_parents(nodes, elist, anc, nodes)

  # calculate changes in relevant part of tree
  minchange <- 3
  min_genes <- 5
  idx <- tre$edge[, 1] %in% nodes2 & tre$edge[, 2] %in% nodes2
  focal <- change.mat[idx, colnames(anc)[i], drop =F]
  if (sum(colSums(change.mat[idx, ,drop=F] != 0) > minchange) > min_genes) {
    cperm2 <- sampleFunc(change.mat, which(idx), 2e4, minchange)
  }
  chit <- change.mat[idx, colnames(anc)[j], drop=F]
  gensize <- gs[tre$edge[idx, 2]] - gs[tre$edge[idx, 1]]

  if (sum(chit != 0) <= minchange | sum(focal != 0) <= minchange) {
    pcors <- NA
    pvs.corr <- NA
    pvs.randomization <- NA
  } else {
    tmp <- pcor.shrink(cbind(focal, chit, gensize), verbose = F)
    pcors <- tmp[2]
    pvs.randomization <- NA
    rm(tmp)

    if (sum(colSums(change.mat[idx, ,drop=F] != 0) > minchange) > min_genes) {
      rand.pcor <- rep(0, ncol(cperm2))
      inds <- dqsample.int(ncol(cperm2), 4e4, replace = T)
      inds <- matrix(inds, nrow = 2e4, ncol = 2)
      tokeep <- apply(inds, 1, function(x) length(unique(x)) == 2)
      inds <- inds[tokeep, ]
      rand.pcor <- pcor_inds(inds,cperm2,gensize)
      if (!is.na(pcors) && pcors > 0) {
        pvr_ind <- !is.na(rand.pcor)
        pvs.randomization <-
          sum(rand.pcor[pvr_ind] >= pcors) / sum(pvr_ind)
      } else {
        pvs.randomization <- NA
        pvs.corr <- NA
      }
      rm(rand.pcor)
    }
  }
  pvs.randomization
}
