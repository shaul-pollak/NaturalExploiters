# ancestral reconstruction of protein copy number, used later to infer co-gain/loss
rm(list=ls())
library(ape)
library(castor)
library(Matrix)
library(data.table)
library(parallel)
ac <- function(i)
{
  require(Matrix)
  require(castor)
  x <- m[,i]
  ar <- castor::asr_squared_change_parsimony(tre,x)$ancestral_states
  ar <- Matrix(round(ar),sparse=T)
  out <- rbind(Matrix(x,sparse=T),ar)
  return(out)
}
bind1 <- function(i)
{
  s <- (i-1)*1000+1
  e <- ifelse(i*1000<length(ancl),i*1000,length(ancl))
  out <- do.call(cbind,ancl[s:e])
  return(out)
}


load("../output/prot_mat.RData")
tre <- read.tree("../output/gtdbtk/binary.tree")
tre <- keep.tip(tre,tre$tip.label[grepl("\\.fna$",tre$tip.label)])
tre$tip.label <- gsub("\\.fna$","",tre$tip.label)
m <- m[tre$tip.label,]
m <- m[,colSums(m)>0]
gensize <- fread(paste0("~/nfs2/ncbiGenomes/input/protein_faa/",
                        "gensize_with_pseudo.tsv"))
setkey(gensize,genome)
gensize <- gensize[rownames(m),]
m <- cbind(m,gensize$length)
colnames(m)[ncol(m)] <- "gensize"
message(ncol(m))

# make parallel cluster
no_cores <- detectCores() - 1
cl <- makeCluster(no_cores)
clusterExport(cl, c("m","tre"))

message("calculating ancestral states")
ancl <- parLapply(cl,1:ncol(m),ac)
clusterExport(cl,"ancl")
message("binding list")
tmp <- parLapply(cl,1:(length(ancl)/1000+1),bind1)
stopCluster(cl)
anc <- do.call(cbind,tmp)
rownames(anc) <- c(tre$tip.label,paste0("node_",1:tre$Nnode))
colnames(anc) <- colnames(m)
save(list=c("tre","m","anc"),file="../output/anc.RData")
