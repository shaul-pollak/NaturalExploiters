###
# preprocessing for figure 1
#
# this script detects clusters of genes that co-evolve with each other based
# on their reconstituted gain/loss histories. All of the genes analyzed
# co-evolve with chitinases
#
# the output of this script is a matrix of genomes x clusters where the entries
# mark cluster presense in a given genome. for a cluster to be considered
# present, 60% of the genes that make up the cluster must be found in the
# analyzed genome. See Supplementary figure S5 for a sensitivity analysis of
# this threshold
###

library(Matrix)
library(data.table)
library(ape)
rm(list=ls())
process_clustering <- function(p)
{
  require(igraph)
  l <- readLines(p)
  l <- strsplit(gsub("V","",l),",")
  l <- sapply(l,function(x) as.integer(x)+1)
  l2 <- lapply(1:length(l),function(x) cbind(x,l[[x]]))
  l2 <- do.call(rbind,l2)
  g <- igraph::graph_from_edgelist(l2,directed=F)
  g <- simplify(g)
  V(g)$name <- colnames(diffs)
  c <- cluster_louvain(g)
}

load("../output/sig_genes.RData")
load("../output/chit_anc.RData")
tre <- read.tree("../output/gtdbtk/binary.tree")
tre <- keep.tip(tre,tre$tip.label[grepl("\\.fna$",tre$tip.label)])
tre$tip.label <- gsub("\\.fna$","",tre$tip.label)
tre <- keep.tip(tre,tre$tip.label[tre$tip.label %in% names(anc.chit)])
chi.change <- anc.chit[tre$edge[,2]] - anc.chit[tre$edge[,1]]

# get summary of Matrix object in triplet format
s <- as.data.table(summary(diffs))

# create new matrix, where even rows represent loses and odd rows represent
# gains
i1 <- s[s[[3]]>0,]
i1[[1]] <- i1[[1]]*2-1
i2 <- s[s[[3]]<0,]
i2[[1]] <- i2[[1]]*2
out <- rbind(i1,i2)
out[[3]] <- abs(out[[3]])

# write to disk
fwrite(out,"../output/minhash/input/mk_diffs.tsv",sep="\t")

# run python script
a <- getwd()
setwd("../output/minhash/scripts")
system("python3 cluster_minhash.py")
setwd(a)

# read clustering
p <- "../output/minhash/output/clustering_0.3.txt"
c <- process_clustering(p)
is <- which(sizes(c)>1)

# break clusters according to chitinase corrected correlation
ma <- max(membership(c))
for(j in 1:length(is))
{
  message(sprintf("%s / %s",j,length(is)))
  i <- which(c$membership==is[j])
  d <- lm(as.matrix(diffs[,i]) ~ chi.change)$residuals
  co <- cor(d[rowSums(d!=0)>0,])
  co[co<.3] <- 0
  g <- igraph::graph_from_adjacency_matrix(co,"undirected",weighted=T)
  gc <- igraph::cluster_louvain(simplify(g))
  if(max(membership(gc))==1) next
  map <- cbind(gc$membership,c$membership[i],ma+gc$membership)
  c$membership[i] <- map[,3]
  ma <- max(map[,3])
}
map <- cbind(1:length(unique(membership(c))),unique(membership(c)))
mv <- match(c$membership,map[,2])
c$membership <- mv

# count modules in genomes
cat("counting modules in each genome\n")
prot_mat_path <- "../output/prot_mat.RData"
load(prot_mat_path)

m <- t(m)[c$names,]
s <- summary(drop0(m))
s2 <- s
s2[,3] <- c$membership[s[,1]]
tmp <- sparseMatrix(i=s2[,1],j=s2[,2],x=s2[,3],dims=dim(m))
tmp2 <- apply(tmp,2,function(x) table(x[x>0]))
ft <- function(i)
{
  x <- tmp2[[i]]
  x
  if(nrow(x)==0) return(NULL)
  sx <- sizes(c)[names(x)] 
  xp <- x/sx
  is <- xp>.6
  if(sum(is)==0) return(NULL)
  out <- data.frame(i = as.integer(names(xp)[is]), j = i,x=1)
  return(out)
}
tmp2 <- lapply(1:length(tmp2),ft )
s2 <- Reduce(rbind,tmp2)

#s2[,1] <- c$membership[s[,1]]
#s2[,3] <- 1
#s2 <- s2[!duplicated(s2),]
mdl_mat <- sparseMatrix(i=s2[,1],j=s2[,2],x=s2[,3],
                        dims=c((max(c$membership) + 1),ncol(m)))
colnames(mdl_mat) <- colnames(m)
rownames(mdl_mat) <- c(paste0("module_", 1:max(c$membership)), "chitinase")

# add chitinases
load("../output/chit_anc.RData")
mdl_mat <- mdl_mat[,tre$tip.label]
m <- m[,tre$tip.label]
chi <- anc.chit[colnames(mdl_mat)]
mdl_mat["chitinase",] <- chi

# create vectors
mdl <- colSums(mdl_mat[setdiff(rownames(mdl_mat), "chitinase"), ])
save_path <- "../output/module_count.RData"
save(list = c("mdl_mat", "chi", "mdl", "g", "c", "m"), file = save_path)
